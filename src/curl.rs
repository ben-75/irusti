pub trait Sponge {
    fn reset(&mut self);
    fn absorb(&mut self, trites_to_calculate :Vec<i8>, offset :usize, length :usize);
    fn squeeze(&mut self, out :&mut [i8;243]);
}

#[derive(PartialEq)]
pub enum SpongeMode {
    CurlP27,
    CurlP81,
    KERL
}

pub struct Curl {
    number_of_rounds:i8,
    state :[i8;729]
}

pub const HASH_LENGTH :usize = 243;
const STATE_LENGTH :usize = 3 * HASH_LENGTH;
const TRUTH_TABLE :[i8;11]= [1, 0, -1, 2, 1, -1, 0, 2, -1, 1, 0];

impl Sponge for Curl {
    fn reset(&mut self) {
        self.state = [0;729];
    }

    fn absorb(&mut self, trites_to_calculate :Vec<i8>) {
        let mut offset :usize =0;
        let mut length :usize =trites_to_calculate.len()*3;
        while {
            let l = if length < HASH_LENGTH {length} else {HASH_LENGTH};
            self.state[0..l].copy_from_slice(&trites_to_calculate[offset..offset+l]);
            self.transform();
            offset += HASH_LENGTH;

            length -= HASH_LENGTH;
            length > 0
        }{}
    }

    fn squeeze(&mut self, &mut  out: [i8;HASH_LENGTH]){
        let mut offset :usize = 0;
        let mut length :usize = HASH_LENGTH;
        while {
            let l = if length < HASH_LENGTH {length} else {HASH_LENGTH};

            out[offset..offset+l].copy_from_slice(&self.state[0..l]);
            self.transform();
            offset += HASH_LENGTH;

            length -= HASH_LENGTH;
            length > 0
        }{}
        out
    }

}

impl Curl {

    pub fn new_curl_p81() -> Curl {
        Curl {
            number_of_rounds:81,
            state : [0;STATE_LENGTH]
        }
    }

    pub fn new_curl_p27() -> Curl {
        Curl {
            number_of_rounds:27,
            state : [0;STATE_LENGTH]
        }
    }

    fn transform(&mut self) {
        let mut scratchpad_index = 0;
        let mut prev_scratchpad_index = 0;
        let mut scratchpad :[i8;STATE_LENGTH] = [0;STATE_LENGTH];
        for _round in 0..self.number_of_rounds {
            scratchpad[0..STATE_LENGTH].copy_from_slice(&self.state[0..STATE_LENGTH]);
            for state_index in 0..STATE_LENGTH {
                prev_scratchpad_index = scratchpad_index;
                scratchpad_index = if scratchpad_index < 365 { scratchpad_index + 364 } else { scratchpad_index - 365 };
                self.state[state_index] = TRUTH_TABLE[(scratchpad[prev_scratchpad_index] + (scratchpad[scratchpad_index] << 2) + 5) as usize];
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use txhash::TxHash;
    use converter;
    use std::time::{Duration, Instant};

    const TRYTES: &str = "RSWWSFXPQJUBJROQBRQZWZXZJWMUBVIVMHPPTYSNW9YQIQQF9RCSJJCVZG9ZWITXNCSBBDHEEKDRBHVTWCZ9SZOOZHVBPCQNPKTWFNZAWGCZ9QDIMKRVINMIRZBPKRKQAIPGOHBTHTGYXTBJLSURDSPEOJ9UKJECUKCCPVIQQHDUYKVKISCEIEGVOQWRBAYXWGSJUTEVG9RPQLPTKYCRAJ9YNCUMDVDYDQCKRJOAPXCSUDAJGETALJINHEVNAARIPONBWXUOQUFGNOCUSSLYWKOZMZUKLNITZIFXFWQAYVJCVMDTRSHORGNSTKX9Z9DLWNHZSMNOYTU9AUCGYBVIITEPEKIXBCOFCMQPBGXYJKSHPXNUKFTXIJVYRFILAVXEWTUICZCYYPCEHNTK9SLGVL9RLAMYTAEPONCBHDXSEQZOXO9XCFUCPPMKEBR9IEJGQOPPILHFXHMIULJYXZJASQEGCQDVYFOM9ETXAGVMSCHHQLFPATWOSMZIDL9AHMSDCE9UENACG9OVFAEIPPQYBCLXDMXXA9UBJFQQBCYKETPNKHNOUKCSSYLWZDLKUARXNVKKKHNRBVSTVKQCZL9RY9BDTDTPUTFUBGRMSTOTXLWUHDMSGYRDSZLIPGQXIDMNCNBOAOI9WFUCXSRLJFIVTIPIAZUK9EDUJJ9B9YCJEZQQELLHVCWDNRH9FUXDGZRGOVXGOKORTCQQA9JXNROLETYCNLRMBGXBL9DQKMOAZCBJGWLNJLGRSTYBKLGFVRUF9QOPZVQFGMDJA9TBVGFJDBAHEVOLW9GNU9NICLCQJBOAJBAHHBZJGOFUCQMBGYQLCWNKSZPPBQMSJTJLM9GXOZHTNDLGIRCSIJAZTENQVQDHFSOQM9WVNWQQJNOPZMEISSCLOADMRNWALBBSLSWNCTOSNHNLWZBVCFIOGFPCPRKQSRGKFXGTWUSCPZSKQNLQJGKDLOXSBJMEHQPDZGSENUKWAHRNONDTBLHNAKGLOMCFYRCGMDOVANPFHMQRFCZIQHCGVORJJNYMTORDKPJPLA9LWAKAWXLIFEVLKHRKCDG9QPQCPGVKIVBENQJTJGZKFTNZHIMQISVBNLHAYSSVJKTIELGTETKPVRQXNAPWOBGQGFRMMK9UQDWJHSQMYQQTCBMVQKUVGJEAGTEQDN9TCRRAZHDPSPIYVNKPGJSJZASZQBM9WXEDWGAOQPPZFLAMZLEZGXPYSOJRWL9ZH9NOJTUKXNTCRRDO9GKULXBAVDRIZBOKJYVJUSHIX9F9O9ACYCAHUKBIEPVZWVJAJGSDQNZNWLIWVSKFJUMOYDMVUFLUXT9CEQEVRFBJVPCTJQCORM9JHLYFSMUVMFDXZFNCUFZZIKREIUIHUSHRPPOUKGFKWX9COXBAZMQBBFRFIBGEAVKBWKNTBMLPHLOUYOXPIQIZQWGOVUWQABTJT9ZZPNBABQFYRCQLXDHDEX9PULVTCQLWPTJLRSVZQEEYVBVY9KCNEZXQLEGADSTJBYOXEVGVTUFKNCNWMEDKDUMTKCMRPGKDCCBDHDVVSMPOPUBZOMZTXJSQNVVGXNPPBVSBL9WWXWQNMHRMQFEQYKWNCSW9URI9FYPT9UZMAFMMGUKFYTWPCQKVJ9DIHRJFMXRZUGI9TMTFUQHGXNBITDSORZORQIAMKY9VRYKLEHNRNFSEFBHF9KXIQAEZEJNQOENJVMWLMHI9GNZPXYUIFAJIVCLAGKUZIKTJKGNQVTXJORWIQDHUPBBPPYOUPFAABBVMMYATXERQHPECDVYGWDGXFJKOMOBXKRZD9MCQ9LGDGGGMYGUAFGMQTUHZOAPLKPNPCIKUNEMQIZOCM9COAOMZSJ9GVWZBZYXMCNALENZ9PRYMHENPWGKX9ULUIGJUJRKFJPBTTHCRZQKEAHT9DC9GSWQEGDTZFHACZMLFYDVOWZADBNMEM9XXEOMHCNJMDSUAJRQTBUWKJF9RZHK9ACGUNI9URFIHLXBXCEODONPXBSCWP9WNAEYNALKQHGULUQGAFL9LB9NBLLCACLQFGQMXRHGBTMI9YKAJKVELRWWKJAPKMSYMJTDYMZ9PJEEYIRXRMMFLRSFSHIXUL9NEJABLRUGHJFL9RASMSKOI9VCFRZ9GWTMODUUESIJBHWWHZYCLDENBFSJQPIOYC9MBGOOXSWEMLVU9L9WJXKZKVDBDMFSVHHISSSNILUMWULMVMESQUIHDGBDXROXGH9MTNFSLWJZRAPOKKRGXAAQBFPYPAAXLSTMNSNDTTJQSDQORNJS9BBGQ9KQJZYPAQ9JYQZJ9B9KQDAXUACZWRUNGMBOQLQZUHFNCKVQGORRZGAHES9PWJUKZWUJSBMNZFILBNBQQKLXITCTQDDBV9UDAOQOUPWMXTXWFWVMCXIXLRMRWMAYYQJPCEAAOFEOGZQMEDAGYGCTKUJBS9AGEXJAFHWWDZRYEN9DN9HVCMLFURISLYSWKXHJKXMHUWZXUQARMYPGKRKQMHVR9JEYXJRPNZINYNCGZHHUNHBAIJHLYZIZGGIDFWVNXZQADLEDJFTIUTQWCQSX9QNGUZXGXJYUUTFSZPQKXBA9DFRQRLTLUJENKESDGTZRGRSLTNYTITXRXRGVLWBTEWPJXZYLGHLQBAVYVOSABIVTQYQM9FIQKCBRRUEMVVTMERLWOK";
    const HASH: &str =
        "TIXEPIEYMGURTQ9ABVYVQSWMNGCVQFASMFAEQWUZCLIWLCDIGYVXOEJBBEMZOIHAYSUQMEFOGZBXUMHQW";

    #[test]
    fn test_curl_works() {

        let now = Instant::now();


            let size = 8019;
            let mut in_trits = converter::trytes_to_trits(TRYTES.to_string());
            let mut hash_trits = [0_i8; HASH_LENGTH];
            let mut curl = Curl::new_curl_p81();
            curl.absorb(in_trits);
        let mut out :[i8;HASH_LENGTH] = [0;HASH_LENGTH];
            hash_trits = curl.squeeze(&mut out);
//            let out_trytes = converter::to_string(hash_trits,81);
//            assert_eq!(HASH, TxHash{arr: hash_trits}.to_string());
        println!("{:?}", now.elapsed());

    }
}
